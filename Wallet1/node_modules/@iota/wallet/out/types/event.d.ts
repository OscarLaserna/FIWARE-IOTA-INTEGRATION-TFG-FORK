import type { IOutputResponse, ITransactionPayload, ITransactionEssence } from '@iota/types';
import type { OutputData } from './output';
import type { InclusionState } from './transaction';
import type { InputSigningData, RemainderData } from './preparedTransactionData';
export type TransactionId = string;
declare class Event {
    /**
     * The account index for which the event was emitted.
     */
    accountIndex: number;
    /**
     * The wallet event.
     */
    event: WalletEvent;
    constructor(accountIndex: number, event: WalletEvent);
}
/**
 * All of the wallet event types.
 */
declare enum WalletEventType {
    ConsolidationRequired = 0,
    LedgerAddressGeneration = 1,
    NewOutput = 2,
    SpentOutput = 3,
    TransactionInclusion = 4,
    TransactionProgress = 5
}
declare abstract class WalletEvent {
    /**
     * The type of the wallet event.
     */
    type: WalletEventType;
    constructor(type: WalletEventType);
}
declare class ConsolidationRequiredWalletEvent extends WalletEvent {
    constructor();
}
declare class LedgerAddressGenerationWalletEvent extends WalletEvent {
    address: string;
    constructor(address: string);
}
declare class NewOutputWalletEvent extends WalletEvent {
    output: OutputData;
    transaction?: ITransactionPayload;
    transactionInputs?: IOutputResponse[];
    constructor(output: OutputData, transaction?: ITransactionPayload, transactionInputs?: IOutputResponse[]);
}
declare class SpentOutputWalletEvent extends WalletEvent {
    output: OutputData;
    constructor(output: OutputData);
}
declare class TransactionInclusionWalletEvent extends WalletEvent {
    transactionId: TransactionId;
    inclusionState: InclusionState;
    constructor(transactionId: TransactionId, inclusionState: InclusionState);
}
/**
 * All of the transaction progress types.
 */
declare enum TransactionProgressType {
    SelectingInputs = 0,
    GeneratingRemainderDepositAddress = 1,
    PreparedTransaction = 2,
    PreparedTransactionEssenceHash = 3,
    SigningTransaction = 4,
    PerformingPow = 5,
    Broadcasting = 6
}
declare class TransactionProgressWalletEvent extends WalletEvent {
    progress: TransactionProgress;
    constructor(progress: TransactionProgress);
}
declare abstract class TransactionProgress {
    type: TransactionProgressType;
    constructor(type: TransactionProgressType);
}
declare class SelectingInputsProgress extends TransactionProgress {
    constructor();
}
declare class GeneratingRemainderDepositAddressProgress extends TransactionProgress {
    address: string;
    constructor(address: string);
}
declare class PreparedTransactionProgress extends TransactionProgress {
    essence: ITransactionEssence;
    inputsData: InputSigningData[];
    remainder?: RemainderData;
    constructor(essence: ITransactionEssence, inputsData: InputSigningData[], remainder?: RemainderData);
}
declare class PreparedTransactionEssenceHashProgress extends TransactionProgress {
    hash: string;
    constructor(hash: string);
}
declare class SigningTransactionProgress extends TransactionProgress {
    constructor();
}
declare class PerformingPowProgress extends TransactionProgress {
    constructor();
}
declare class BroadcastingProgress extends TransactionProgress {
    constructor();
}
export { Event, WalletEventType, WalletEvent, ConsolidationRequiredWalletEvent, LedgerAddressGenerationWalletEvent, NewOutputWalletEvent, SpentOutputWalletEvent, TransactionInclusionWalletEvent, TransactionProgressWalletEvent, TransactionProgress, SelectingInputsProgress, GeneratingRemainderDepositAddressProgress, PreparedTransactionProgress, PreparedTransactionEssenceHashProgress, SigningTransactionProgress, PerformingPowProgress, BroadcastingProgress, TransactionProgressType, };
//# sourceMappingURL=event.d.ts.map