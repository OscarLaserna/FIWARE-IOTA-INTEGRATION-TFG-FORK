"use strict";
// Copyright 2021 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountManager = void 0;
const MessageHandler_1 = require("./MessageHandler");
const Account_1 = require("./Account");
/** The AccountManager class. */
class AccountManager {
    constructor(options) {
        this.messageHandler = new MessageHandler_1.MessageHandler(options);
    }
    /**
     * Backup the data to a Stronghold snapshot.
     */
    async backup(destination, password) {
        await this.messageHandler.sendMessage({
            cmd: 'backup',
            payload: {
                destination,
                password,
            },
        });
    }
    /**
     * Transform a bech32 encoded address to a hex encoded address
     */
    async bech32ToHex(bech32Address) {
        const response = await this.messageHandler.sendMessage({
            cmd: 'bech32ToHex',
            payload: { bech32Address },
        });
        return JSON.parse(response).payload;
    }
    /**
     * Change the Stronghold password.
     */
    async changeStrongholdPassword(currentPassword, newPassword) {
        await this.messageHandler.sendMessage({
            cmd: 'changeStrongholdPassword',
            payload: {
                currentPassword,
                newPassword,
            },
        });
    }
    /**
     * Clear the Stronghold password from memory.
     */
    async clearStrongholdPassword() {
        await this.messageHandler.sendMessage({
            cmd: 'clearStrongholdPassword',
        });
    }
    /**
     * Create a new account.
     */
    async createAccount(payload) {
        const response = await this.messageHandler.sendMessage({
            cmd: 'createAccount',
            payload,
        });
        return new Account_1.Account(JSON.parse(response).payload, this.messageHandler);
    }
    /**
     * Destroy the AccountManager and drop its database connection.
     */
    async destroy() {
        await this.messageHandler.destroy();
    }
    /**
     * Emit a provided event for testing of the event system.
     */
    async emitTestEvent(event) {
        await this.messageHandler.sendMessage({
            cmd: 'emitTestEvent',
            payload: { event },
        });
    }
    /**
     * Generate a random BIP39 mnemonic.
     */
    async generateMnemonic() {
        const response = await this.messageHandler.sendMessage({
            cmd: 'generateMnemonic',
        });
        return JSON.parse(response).payload;
    }
    /**
     * Get an account by its alias or index.
     */
    async getAccount(accountId) {
        const response = await this.messageHandler.sendMessage({
            cmd: 'getAccount',
            payload: { accountId },
        });
        const account = new Account_1.Account(JSON.parse(response).payload, this.messageHandler);
        return account;
    }
    /**
     * Get all account indexes.
     */
    async getAccountIndexes() {
        const response = await this.messageHandler.sendMessage({
            cmd: 'getAccountIndexes',
        });
        return JSON.parse(response).payload;
    }
    /**
     * Get all accounts.
     */
    async getAccounts() {
        const response = await this.messageHandler.sendMessage({
            cmd: 'getAccounts',
        });
        const { payload } = JSON.parse(response);
        const accounts = [];
        for (const account of payload) {
            accounts.push(new Account_1.Account(account, this.messageHandler));
        }
        return accounts;
    }
    /**
     * Generate an address without storing it.
     */
    async generateEd25519Address(accountIndex, addressIndex, options, bech32Hrp) {
        const response = await this.messageHandler.sendMessage({
            cmd: 'generateEd25519Address',
            payload: {
                accountIndex,
                addressIndex,
                options,
                bech32Hrp,
            },
        });
        return JSON.parse(response).payload;
    }
    /**
     * Get the node info.
     */
    async getNodeInfo(url, auth) {
        const response = await this.messageHandler.sendMessage({
            cmd: 'getNodeInfo',
            payload: { url, auth },
        });
        return JSON.parse(response).payload;
    }
    /**
     * Get the status for a Ledger Nano.
     */
    async getLedgerNanoStatus() {
        const response = await this.messageHandler.sendMessage({
            cmd: 'getLedgerNanoStatus',
        });
        return JSON.parse(response).payload;
    }
    /**
     * Transform hex encoded address to bech32 encoded address. If no bech32Hrp
     * is provided, the AccountManager will attempt to retrieve it from the
     * NodeInfo. If this does not succeed, it will default to the Shimmer testnet bech32Hrp.
     */
    async hexToBech32(hex, bech32Hrp) {
        const response = await this.messageHandler.sendMessage({
            cmd: 'hexToBech32',
            payload: { hex, bech32Hrp },
        });
        return JSON.parse(response).payload;
    }
    /**
     * Check if the Stronghold password has been set.
     */
    async isStrongholdPasswordAvailable() {
        const response = await this.messageHandler.sendMessage({
            cmd: 'isStrongholdPasswordAvailable',
        });
        return JSON.parse(response).payload;
    }
    /**
     * Listen to wallet events with a callback. An empty array will listen to all possible events.
     */
    async listen(eventTypes, callback) {
        return this.messageHandler.listen(eventTypes, callback);
    }
    /**
     * Clear the callbacks for provided events. An empty array will clear all listeners.
     */
    async clearListeners(eventTypes) {
        const response = await this.messageHandler.sendMessage({
            cmd: 'clearListeners',
            payload: { eventTypes },
        });
        return JSON.parse(response).payload;
    }
    /**
     * Find accounts with unspent outputs.
     */
    async recoverAccounts(accountStartIndex, accountGapLimit, addressGapLimit, syncOptions) {
        const response = await this.messageHandler.sendMessage({
            cmd: 'recoverAccounts',
            payload: {
                accountStartIndex,
                accountGapLimit,
                addressGapLimit,
                syncOptions,
            },
        });
        const accounts = [];
        for (const account of JSON.parse(response).payload) {
            accounts.push(new Account_1.Account(account, this.messageHandler));
        }
        return accounts;
    }
    /**
     * Delete the latest account.
     */
    async removeLatestAccount() {
        await this.messageHandler.sendMessage({
            cmd: 'removeLatestAccount',
        });
    }
    /**
     * Restore a backup from a Stronghold file
     * Replaces client_options, coin_type, secret_manager and accounts. Returns an error if accounts were already created
     * If Stronghold is used as secret_manager, the existing Stronghold file will be overwritten. If a mnemonic was
     * stored, it will be gone.
     * if ignore_if_coin_type_mismatch is provided client options will not be restored
     * if ignore_if_coin_type_mismatch == true, client options coin type and accounts will not be restored if the cointype doesn't match
     * if ignore_if_bech32_hrp_mismatch == Some("rms"), but addresses have something different like "smr", no accounts
     * will be restored.
     */
    async restoreBackup(source, password, ignoreIfCoinTypeMismatch, ignoreIfBech32Mismatch) {
        await this.messageHandler.sendMessage({
            cmd: 'restoreBackup',
            payload: {
                source,
                password,
                ignoreIfCoinTypeMismatch,
                ignoreIfBech32Mismatch,
            },
        });
    }
    /**
     * Set ClientOptions.
     */
    async setClientOptions(clientOptions) {
        await this.messageHandler.sendMessage({
            cmd: 'setClientOptions',
            payload: { clientOptions },
        });
    }
    /**
     * Set the Stronghold password.
     */
    async setStrongholdPassword(password) {
        await this.messageHandler.sendMessage({
            cmd: 'setStrongholdPassword',
            payload: { password },
        });
    }
    /**
     * Set the interval after which the Stronghold password gets cleared from memory.
     */
    async setStrongholdPasswordClearInterval(intervalInMilliseconds) {
        await this.messageHandler.sendMessage({
            cmd: 'setStrongholdPasswordClearInterval',
            payload: { intervalInMilliseconds },
        });
    }
    /**
     * Start the background syncing process for all accounts.
     */
    async startBackgroundSync(options, intervalInMilliseconds) {
        await this.messageHandler.sendMessage({
            cmd: 'startBackgroundSync',
            payload: {
                options,
                intervalInMilliseconds,
            },
        });
    }
    /**
     * Stop the background syncing process for all accounts.
     */
    async stopBackgroundSync() {
        await this.messageHandler.sendMessage({
            cmd: 'stopBackgroundSync',
        });
    }
    /**
     * Store a mnemonic in the Stronghold snapshot.
     */
    async storeMnemonic(mnemonic) {
        await this.messageHandler.sendMessage({
            cmd: 'storeMnemonic',
            payload: { mnemonic },
        });
    }
    /**
     * Verify if a mnemonic is a valid BIP39 mnemonic.
     */
    async verifyMnemonic(mnemonic) {
        await this.messageHandler.sendMessage({
            cmd: 'verifyMnemonic',
            payload: { mnemonic },
        });
    }
    /**
     * Update the authentication for the provided node.
     */
    async updateNodeAuth(url, auth) {
        await this.messageHandler.sendMessage({
            cmd: 'updateNodeAuth',
            payload: { url, auth },
        });
    }
}
exports.AccountManager = AccountManager;
//# sourceMappingURL=AccountManager.js.map